import { writeFileSync, mkdirSync, existsSync } from 'node:fs'
import { dirname, normalize } from 'node:path'
import { rimrafSync } from 'rimraf'
import { gray, greenBright, redBright, yellowBright, blueBright } from 'ansis'
import { useNuxt } from '@nuxt/kit'

export function createFile(path: string, content: string) {
  const dirs = dirname(path)
  if(!existsSync(dirs)) mkdirSync(dirs, { recursive: true })

  rimrafSync(path)
  writeFileSync(path, content, { encoding: 'utf-8' })
}

export function capitalize(word: string) {
  return word?.split(' ').map(x => x.charAt(0).toUpperCase() + x.slice(1)).join(' ')
}

export function log(text: string, kind: 'default' | 'success' | 'error' | 'warning') {
  const kindToColor = {
    default: gray,
    success: greenBright,
    error: redBright,
    warning: yellowBright
  }

  console.log(kindToColor[kind](`  ${blueBright`[ApiGenerator]`}: ${text}\n`))
}

/**
 * Resolve a path relative to the `srcDir` of the Nuxt application.
 *
 * @param paths - The path parts to resolve.
 * @returns The resolved path.
 */
export function resolve(...paths: string[]) {
  return baseResolve(useNuxt().options.workspaceDir, '/src/', ...paths)
}

/**
 * Resolve a path relative to the build or autogenerated directory.
 *
 * @param paths - The path parts to resolve. The last part can be 'root' to
 *                resolve to the root of the build directory, or a string to
 *                resolve to a autogenerated directory.
 * @returns The resolved path.
 */
export function resolveBuild(...paths: [...string[], 'root' | string]) {
  return baseResolve(useNuxt().options.buildDir, paths.reverse()[0] === 'root' ? '' : '/autogenerated/', ...paths)
}

function baseResolve(...paths: string[]) {
  const normalizedBasePath = paths[0].replace(/\\/g, '/')
  const normalizedRelativePath = paths.slice(1).join('').replace(/\\/g, '/')

  const baseSegments = normalizedBasePath.split('/')
  const relativeSegments = normalizedRelativePath.split('/')

  relativeSegments.forEach((segment: string) => {
    if (segment === '..') {
      baseSegments.pop()
    } else if (segment && baseSegments[baseSegments.length - 1] !== segment) {
      baseSegments.push(segment)
    }
  })

  return normalize(baseSegments.join('/')).replace(/\\/g, '/')
}
