import { writeFileSync, mkdirSync, existsSync } from 'node:fs'
import { dirname, normalize, resolve as pathResolve } from 'node:path'
import { rimrafSync } from 'rimraf'
import { gray, greenBright, redBright, yellowBright, blueBright } from 'ansis'
import { useNuxt } from '@nuxt/kit'

export function createFile(path: string, content: string) {
  const dirs = dirname(path)
  if(!existsSync(dirs)) mkdirSync(dirs, { recursive: true })

  rimrafSync(path)
  writeFileSync(path, content, { encoding: 'utf-8' })
}

export function capitalize(word: string) {
  return word?.split(' ').map(x => x.charAt(0).toUpperCase() + x.slice(1)).join(' ')
}

export function log(text: string, kind: 'default' | 'success' | 'error' | 'warning') {
  const kindToColor = {
    default: gray,
    success: greenBright,
    error: redBright,
    warning: yellowBright
  }

  console.log(kindToColor[kind](`  ${blueBright`[ApiGenerator]`}: ${text}\n`))
}

/**
 * Resolve a path relative to the `srcDir` of the Nuxt application.
 *
 * @param paths - The path parts to resolve.
 * @returns The resolved path.
 */
export function resolve(...paths: string[]) {
  return baseResolve(process.cwd(), '/src/', ...paths)
}

/**
 * Resolve a path relative to the build or autogenerated directory.
 *
 * @param paths - The path parts to resolve. The last part can be 'root' | 'server' to
 *                resolve to the specific build or autogenerated directory.
 * @returns The resolved path.
 */
export function resolveBuild(...paths: [...string[], 'root' | 'server' | string]) {
  const isLiteral = ['root', 'server', 'theme'].includes(paths[paths.length - 1])
  const literalToPath = {
    root: '/autogenerated/',
    server: '../../server',
  }[paths[paths.length - 1]]

  const p = !isLiteral ? paths : paths.slice(0, -1)
  return baseResolve(useNuxt().options.buildDir, !isLiteral ? '' : literalToPath, ...p)
}

function baseResolve(...paths: string[]) {
  const normalizedBasePath = paths[0].replace(/\\/g, '/')
  const normalizedRelativePath = pathResolve(...paths).replace(/\\/g, '/')
  console.log(getCallerFile());


  const baseSegments = normalizedBasePath.split('/')
  const relativeSegments = normalizedRelativePath.split('/')

  relativeSegments.forEach((segment: string) => {
    if (segment === '..' || baseSegments.includes(segment)) {
      baseSegments.filter(x => x !== segment)
    } else if (segment && baseSegments[baseSegments.length - 1] !== segment) {
      baseSegments.push(segment)
    }
  })

  return normalize(baseSegments.join('/')).replace(/\\/g, '/')
}

function getCallerFile(): string | undefined {
  const originalFunc = Error.prepareStackTrace
  let callerFile: string | undefined

  try {
    const err = new Error()
    Error.prepareStackTrace = (err, stack) => stack

    const stack = err.stack as unknown as NodeJS.CallSite[]
    const currentFile = stack[0]?.getFileName()

    callerFile = stack.find(site => site.getFileName() !== currentFile)?.getFileName()
  } catch (e) {
    console.error(e)
  } finally {
    Error.prepareStackTrace = originalFunc
  }

  return callerFile ? pathResolve(callerFile) : undefined;
}
